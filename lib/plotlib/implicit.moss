
begin
use plotlib: System
use elib.optimizer: zeroes_bisection
use math: pi, floor, cos

extend(System,{
   function plot_zero_set(f,argm={})
      canvas = self.c
      wx = self.wx; px = self.px; ax = self.ax
      wy = self.wy; py = self.py; ay = self.ay
      px = px-ax*wx
      py = py-ay*wy
      {m=10, point = canvas.point, r=0.02, method="bisection"} = argm
      if method=="bisection"
         {n=1000} = argm
         step = wx/n
         xa = px-wx; xb = px+wx
         ya = py-wy; yb = py+wy
         for x in xa..xb: step
            a = zeroes_bisection(|y| f(x,y),ya,yb,m)
            for y in a
               point(canvas;(x-px)/wx,(y-py)/wy)
            end
         end
         for y in ya..yb: step
            a = zeroes_bisection(|x| f(x,y),xa,xb,m)
            for x in a
               point(canvas;(x-px)/wx,(y-py)/wy)        
            end
         end
      else
         {n=400} = argm
         step = wx/n
         for y in py-wy..py+wy: step
            for x in px-wx..px+wx: step
               if abs(f(x,y))<r
                  point(canvas;(x-px)/wx,(y-py)/wy)
               end
            end
         end
      end
      if not self.lock
         self.next_color()
      end
   end,

   function plot_level(f,argm={})
      canvas = self.c
      {n=4,freq=1,alpha=0.4,phi0=4*pi/3} = argm
      W = self.w//n
      H = self.h//n
      ratio = H/W
      ai = 2/(W-1)
      aj = 2/(H-1)
      wx = self.wx; px = self.px; ax = self.ax
      wy = self.wy; py = self.py; ay = self.ay
      px = px-ax*wx
      py = py-ay*wy
      # grid(self,canvas,self.w,self.h,[0,0,0],[0,0,0,0.4],self.fscale)
      tau = 2*pi
      for j in 0..H-1
         for i in 0..W-1
            x = px+(ai*i-1)*wx
            y = py-(aj*j-1)*ratio*wy
            z = phi0-freq*f(x,y)
            # L = 0.5-0.5*cos(tau*z)
            # canvas.hsl(3.4,sat,0.1,L*alpha)
            phi = z-tau*floor(z/tau)
            canvas.hsl(phi,1,0.5,alpha)
            canvas.fill(i*n,j*n,n,n)
         end
      end
   end
})

end


