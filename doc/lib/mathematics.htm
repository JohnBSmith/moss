<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Mathematics</title>
  <link href="../css/main.css" rel="stylesheet">
  <script src="../js/moss-syntax.js"></script>
</head>
<body>

<table class="navigation">
<tr><td><b>&uarr;</b> <a href="toc.htm">Up</a>
</table>
<h1>Mathematics</h1>

<div class="toc">
<h2 id="toc">Table of contents</h2>
<ol>
<li><a href="#math">Module <code>math</code> &mdash; elementary functions</a>
<li><a href="#cmath">Module <code>cmath</code> &mdash; complex functions</a>
<li><a href="#math-rational">Module <code>math.rational</code> &mdash; rational numbers</a>
<li><a href="#math-nt">Module <code>math.nt</code> &mdash; number theory</a>
<li><a href="#math-cf">Module <code>math.cf</code> &mdash; combinatorical functions</a>
<li><a href="#math-sf">Module <code>math.sf</code> &mdash; special functions</a>
<li><a href="#math-sf-ei">Module <code>math.sf.ei</code> &mdash; elliptic integrals</a>
<li><a href="#math-la">Module <code>math.la</code> &mdash; linear algebra</a>
<li><a href="#math-na">Module <code>math.na</code> &mdash; numerical algorithms</a>
<li><a href="#math-na-quad">Module <code>math.na.quad</code> &mdash; numerical quadrature</a>
</ol>
</div>

<h2 id="math">Module math</h2>
<p>Elementary mathematical functions.

<dl class="code">
<dt>e
<dd>Euler's number: <code>2.71828...</code>

<dt>pi
<dd>Half length of the unit circle: <code>3.14159...</code>

<dt>tau
<dd>Length of the unit circle: <code>2*pi</code>.

<dt>nan
<dd>Not a number.

<dt>inf
<dd>Infinity.

<dt>floor(x)
<dd>Round down. Returns floating point numbers.

<dt>ceil(x)
<dd>Round up. Returns floating point numbers.

<dt>sqrt(x)
<dd>Square root of <code>x</code>.

<dt>exp(x)
<dd>Exponential function.

<dt>log2(x)
<dd>Logarithm to base 2.

<dt>ln(x)
<dd>Logarithm to base e.

<dt>lg(x)
<dd>Logarithm to base 10.

<dt>lg(x,b)
<dd>Logarithm to base <code>b</code>.

<dt>sin(x), cos(x), tan(x)
<dd>Sine, cosine and tangent.

<dt>asin(x), acos(x), atan(x)
<dd>Arc sine, arc cosine and arc tangent.

<dt>sinh(x), cosh(x), tanh(x)
<dd>Hyperbolic sine, hyperbolic cosine and hyperbolic tangent.

<dt>asinh(x), acosh(x), atanh(x)
<dd>Inverse functions of the hyperbolic functions.

<dt>fac(x)
<dd>Factorial function. Returns floating point numbers.

<dt>gamma(x)
<dd>Gamma function.

<dt>lgamma(x)
<dd>Return <code>ln(abs(gamma(x)))</code>.

<dt>sgngamma(x)
<dd>Return <code>sgn(gamma(x))</code>.

<dt>erf(x)
<dd>Error function.

<dt>hypot(x1,...,xn)
<dd>Return <code>sqrt(x1^2+...+xn^2)</code>.

<dt>atan2(y,x)
<dd>Return the phase angle of the coordinate vector
<code>[x,y]</code>.

<dt>expm1(x)
<dd>Return <code>exp(x)-1</code>.

<dt>ln1p(x)
<dd>Return <code>ln(1+x)</code>.

<dt>isfinite(x)
<dd>Return true if <code>x</code> is not infinite and not a NaN.

<dt>isnan(x)
<dd>Return true if <code>x</code> is a NaN.

<dt>isinf(x)
<dd>Return true if <code>x</code> is infinite.

<dt>frexp(x)
<dd>Take <code>x==m*2^n</code> and return <code>[m,n]</code>.
The type of <code>m</code> is float, the type of <code>n</code> is int.

<dt>ldexp(m,n)
<dd>Return <code>m*2^n</code>.
</dl>


<h2 id="cmath">Module cmath</h2>
<p>Elementary mathematical functions that can take or return complex
numbers.

<dl class="code">
<dt>re(z)
<dd>Real part of <code>z</code>.

<dt>im(z)
<dd>Imaginary part of <code>z</code>.

<dt>conj(z)
<dd>Complex conjugate.

<dt>sqrt(z)
<dd>Square root.

<dt>exp(z)
<dd>Exponential function.

<dt>ln(z)
<dd>Natural logarithm.

<dt>sin(z), cos(z), tan(z)
<dd>Sine, cosine and tangent.

<dt>sinh(z), cosh(z), tanh(z)
<dd>Hyperbolic sine, hyperbolic cosine and hyperbolic tangent.

<dt>asinh(z), acosh(z), atanh(z)
<dd>Inverse functions of the hyperbolic functions.

<dt>gamma(z)
<dd>Gamma function.
</dl>


<h2 id="math-rational">Module math.rational</h2>

<dl class="code">
<dt>Rat
<dd>Rational numbers data type.

<dt>rat(n,d=1)
<dd>Rational number <code>n/d</code>.

<dt>r.n
<dd>Numerator.

<dt>r.d
<dd>Denominator.
</dl>


<h2 id="math-nt">Module math.nt</h2>

<p>Number theory.

<dl class="code">
<dt>base(n,b)
<dd>Transform the number <code>n</code> into positional notation
by base <code>b</code>. The result is in little endian
(least significant digit first).

<dt>base(n,b).rev()
<dd>Big endian (least significant digit last) of the
positional notation above.

<dt>isprime(n)
<dd>Deterministic primality test.

<dt>isprime(n,e)
<dd>Probalistic primality test with false positive probability of less than
<code>1/(4^e)</code>.

<dt>gcd(a,b)
<dd>Greatest common divisor of <code>a</code> and <code>b</code>.

<dt>lcm(a,b)
<dd>Least common multiple of <code>a</code> and <code>b</code>.

<dt>lcm(a)
<dd>Least common multiple of the numbers in the iterable <code>a</code>.

<dt>factor(n)
<dd>Prime factorization of <code>n</code>.

<dt>divisors(n)
<dd>The list of divisors of <code>n</code>.

<dt>phi(n)
<dd>Euler's totient function.

<dt>lambda(n)
<dd>Carmichael function.
</dl>

<h2 id="math-cf">Module math.cf</h2>
<p>Combinatorical functions.

<dl class="code">
<dt>fac(n)
<dd>Factorial function.

<dt>rf(n,k)
<dd>Raising factorial.

<dt>ff(n,k)
<dd>Falling factorial.

<dt>bc(n,k)
<dd>Binomial coefficient.

<dt>mc([k1,...,kn])
<dd>Multinomial coefficient.

<dt>stirling1(n,k)
<dd>Stirling number of the first kind.

<dt>stirling2(n,k)
<dd>Stirling number of the second kind.

<dt>euler1(n,k)
<dd>Eulerian number.

<dt>euler2(n,k)
<dd>Eulerian number of the second order.

<dt>bell(n)
<dd>Bell numbers.

<dt>pf(n)
<dd>Partition function.

<dt>pf(n,k)
<dd>Number of partitions of <code>n</code> into exactly <code>k</code>
parts.

<dt>permutations(a)
<dd>Permutations of the list <code>a</code>.

<dt>combinations(k,s)
<dd>Combinations of set/list/string <code>s</code> into
  sets of <code>k</code> elements.

<dt>partitions(n,k)
<dd>Partitions of <code>n</code> into <code>k</code> parts.
</dl>

<h2 id="math-sf">Module math.sf</h2>
<p>Special functions.

<dl class="code">
<dt>PP(n,m,x)
<dd>Associated Legendre function
<span class="math"><var>P</var><sub><var>n</var>,<var>m</var></sub>(<var>x</var>)</span>.

<dt>PH(n,x)
<dd>Hermite polynomial
<span class="math"><var>H</var><sub><var>n</var></sub>(<var>x</var>)</span>.

<dt>PT(n,x)
<dd>Chebyshev polynomial of the first kind:
<span class="math"><var>T</var><sub><var>n</var></sub>(<var>x</var>)</span>.

<dt>PU(n,x)
<dd>Chebyshev polynomial of the second kind:
<span class="math"><var>U</var><sub><var>n</var></sub>(<var>x</var>)</span>.

<dt>gamma(s,x)
<dd>Lower incomplete gamma function
<span class="math">&gamma;(<var>s</var>,<var>x</var>)</span>.

<dt>Gamma(s,x)
<dd>Upper incomplete gamma function
<span class="math">&Gamma;(<var>s</var>,<var>x</var>)</span>.

<dt>zeta(x)
<dd>Zeta function.

<dt>B(n)
<dd>Bernoulli number, <code>B(1)&nbsp;=&nbsp;+1/2</code>.
</dl>


<h2 id="math-sf-ei">Module math.sf.ei</h2>
<p>Elliptic integrals.

<dl class="code">
<dt>K(m), m=k^2
<dd>Complete elliptic integral of the first kind.

<dt>E(m), m=k^2
<dd>Complete elliptic integral of the second kind.

<dt>F(phi,m), m=k^2
<dd>Incomplete elliptic integral of the first kind.

<dt>E(phi,m), m=k^2
<dd>Incomplete elliptic integral of the second kind.

<dt>Pi(phi,n,m), m=k^2
<dd>Incomplete elliptic integral of the third kind.

<dt>RF(x,y,z)
<dd>Carlson symmetric form
<span class="math"><var>R</var><sub><var>F</var></sub>(<var>x</var>,&nbsp;<var>y</var>,&nbsp;<var>z<var>)</span>.

<dt>RC(x,y)
<dd>Carlson symmetric form
<span class="math"><var>R</var><sub><var>C</var></sub>(<var>x</var>,&nbsp;</var>y</var>)
= <var>R</var><sub><var>F</var></sub>(<var>x</var>,&nbsp;<var>y</var>,&nbsp;<var>y<var>)</span>.

<dt>RJ(x,y,z,p)
<dd>Carlson symmetric form
<span class="math"><var>R</var><sub><var>J</var></sub>(<var>x</var>,&nbsp;<var>y</var>,&nbsp;<var>z</var>,&nbsp;<var>p</var>)</span>.

<dt>RD(x,y,z)
<dd>Carlson symmetric form
<span class="math"><var>R</var><sub><var>D</var></sub>(<var>x</var>,&nbsp;<var>y</var>,&nbsp;<var>z<var>)
= <var>R</var><sub><var>J</var></sub>(<var>x</var>,&nbsp;<var>y</var>,&nbsp;<var>z</var>,&nbsp;<var>z</var>)</span>.

</dl>

<h2 id="math-la">Module math.la</h2>
<p>Linear algebra by polymorphic multidimensional arrays.

<dl class="code">
<dt>vector(a1,...,an)
<dd>Build a coordinate vector.

<dt>matrix([a11,...,a1n],...,[am1,...,amn])
<dd>Build a matrix.

<dt>matrix(vector(a11,...,am1),...,vector(a1n,...,amn))
<dd>Build a matrix from column vectors.

<dt>array(N,data)
<dd>Return a coordinate tensor of order <code>N</code>.
Note that:
<pre class="code">
array(1,a) = vector(*a),
array(2,a) = matrix(*a).
</pre>

<dt>vec(a1,...,an)
<dd>A shorthand for <code>vector</code>.

<dt>diag(a1,...,an)
<dd>Return a diagonal matrix.

<dt>scalar(n,lambda,zero)
<dd>Return a scalar <var>n</var>&times;<var>n</var> matrix.

<dt>scalar(n,1,0)
<dd>Return the <var>n</var>&times;<var>n</var> identity matrix.
</dl>

<b>Type Array, <code>a,b,A,B,v,w: Array</code></b>
<dl class="code">
<dt>a.T
<dd>Transposed matrix.

<dt>a.H
<dd>Conjugate transpose.

<dt>a.conj
<dd>Conjugated complex matrix.

<dt>a.tr
<dd>Trace.

<dt>a.diag
<dd>Main diagonal as a coordinate vector.

<dt>a.shape
<dd>Shape of the array.

<dt>a.copy
<dd>Shallow copy of the array.

<dt>abs(a)
<dd>Absolute value of a vector. Frobenius norm of a matrix.

<dt>a+b, a-b, -a, r*a, a/r
<dd>Pointwise operations.

<dt>v*w, v.conj*w
<dd>Scalar product, scalar product of complex vectors.

<dt>v.T*w, v.H*w
<dd>Scalar product of column matrices, scalar product of complex
column matrices.

<dt> A*v, A*B
<dd>Multiplication matrix*vector, multiplication matrix*matrix.

<dt>A^n
<dd>Matrix power.

<dt>a.list()
<dd>Convert the array into a list.

<dt>a.map(f)
<dd>Applies <code>f</code> to every element of <code>a</code>.

<dt>a[k]
<dd>Component of a vector (<code>k=0</code> up to <code>k=n-1</code>).
Row of a matrix.

<dt>a[i,j]
<dd>Component of a matrix.
</dl>

<h2 id="math-na">Module math.na</h2>
<p>Numerical algorithms.

<dl class="code">
<dt>pli(x0,d,a)
<dd>Return a function that computes a piecewise linear interpolation
of the given equidistant nodes <code>[x[k],y[k]]=[x0+k*d,a[k]]</code>
for <code>k</code> in <code>0..len(a)-1</code>. Note that
<code>a</code> may contain vectors or a matrices. Vectors are
interpolated componentwise.

<dt>inv(f,y,a,b)
<dd>Calculate the preimage <code>x0</code> by bisection
such that <code>y</code>&approx;<code>f(x0)</code>. The function
<code>f(x)-y</code> should change its sign on <code>x&in;[a,b]</code>
only once at <code>x=x0</code>.

<dt>diffh({h=0.001,order=false,fast=false})
<dd>Create a numerical derivative operation <code>diff=diffh()</code>.
Apply <code>diff(f,a)</code> to calculate <code>f'(x)</code>
at <code>x=a</code>. If <code>order</code> is true,
apply <code>diff(f,a,n)</code> instead to calculate the nth
derivative. If <code>fast</code> is true, use a slightly faster
algorithm for the first derivative. Note that <code>f</code> may also
be a complex function or a vector-valued function.
For a given smooth function, a smaller <code>h</code> leads to
a better approximation, unless <code>h</code> is too small.

<dt>diffvh({h=0.001,order=false,fast=false})
<dd>Create a directional derivative operation
<code>diffv=diffvh()</code>. Apply <code>diffv(v,f,a)</code>
to calculate <code>diff(|t| f(a+t*v),0)</code>.

<dt>integral(a,b,f,n=1)
<dd>Calculate the definite integral of <code>f(x)</code>
for <code>x=a</code> to <code>x=b</code>. Uses a Gauss-Legendre
quadrature with 32 nodes. To increase accuracy, the interval
<code>[a,b]</code> can be subdivided into <code>n</code> parts.
Note that <code>f</code> may be a complex-valued or vector-valued
function.
</dl>

<h2 id="math-na-quad">Module math.na.quad</h2>
<p>Numerical quadrature.

<dl class="code">
<dt>gauss_legendre(N)
<dd>Return a new integral operation, using the Gauss-Legendre
quadrature with <code>N</code> nodes.
<pre class="moss">
integral = gauss_legendre(64)
ln = |x| integral(1,x,|t| 1/t)
# integral(a,b,f,n=1)
</pre>

<dt>legendre_nodes(N)
<dd>The nodes for the Gauss-Legendre quadrature.

<dt>gauss(nodes)
<dd>Take <code>nodes</code> and return a new integral operation by
Gaussian quadrature.
<pre class="moss">
integral = gauss(legendre_nodes(64))
</pre>
</dl>

</body>
</html>

