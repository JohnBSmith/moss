<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Object system</title>
  <link rel="stylesheet" href="../css/main.css">
  <script src = "../js/moss-syntax.js">
  </script>
</head>
<body>

<table class="navigation">
<tr><td><b>&uarr;</b> <a href="toc.htm">Up</a>
</table>
<h1>Object system</h1>

<div class="toc">
<h2 id="toc">Table of contents</h2>
<ol>
<li><a href="#a-simple-class">A simple class</a>
<li><a href="#constructors">Constructors</a>
<li><a href="#destructors">Destructors</a>
<li><a href="#type-checks">Runtime type checks</a>
<li><a href="#inheritance">Inheritance</a>
<li><a href="#multiple-inheritance">Multiple inheritance</a>
<li><a href="#composition">Composition over inheritance</a>
<li><a href="#reflection">Reflection</a>
<li><a href="#aop">Aspect-oriented programming</a>
</ol>

<p>[outdated:]
<ol>
<li><a href="#prototypes">Prototypes</a>
<li><a href="#classes-and-metaclasses">Classes and Metaclasses</a>
<li><a href="#monkey">Monkey patching</a>
<li><a href="#overloading">Operator overloading</a>
<li><a href="#read-only">Read-only properties</a>
<li><a href="#private">Private properties</a>
<li><a href="#advanced">Advanced classes</a>
<li><a href="#custom">Custom class constructors</a>
</ol>
</div>

<h2 id="a-simple-class">A simple class</h2>

<p>As a first example, a class with a method <code>quack</code>
is stated.

<pre class="moss indent">
class Duck = {
   function quack()
      print(self.name, " quacks.")
   end
}

d = table Duck{name = "Dagobert"}
d.quack()
</pre>

<p>Object properties shadow class properties. For example,
the method <code>quack</code> may be shadowed by a
special method:

<pre class="moss indent">
d.quack = fn||
   print(self.name, " quacks loudly.")
end

d.quack()
</pre>

<h2 id="constructors">Constructors</h2>

<p>Objects are constructed by ordinary functions.
For example, a function <code>duck</code> may create
an object of class <code>Duck</code>.

<pre class="moss indent">
function duck(name)
   return table Duck{name=name}
end

d = duck("Dagobert")
d.quack()
</pre>

<p>It can be moved into the class, that is only a matter of style:
<pre class="moss indent">
class Duck = {
   function quack()
      print(self.name, " quacks.")
   end,
   function new(name)
      return table Duck{name=name}
   end
}

d = Duck.new("Dagobert")
d.quack()
</pre>


<h2 id="destructors">Destructors</h2>

<p>When an object is not needed anymore, a destructor method
<code>drop</code> may be called automatically. It is a special method
that can only be stated at class construction and cannot
be shadowed by local properties.

<pre class="moss indent">
class Duck = {
   function quack()
      print(self.name, " quacks.")
   end,
   function drop()
      print(self.name, " flies away.")
   end
}
</pre>

<h2 id="type-checks">Runtime type checks</h2>

<p>Type checks are performed in two ways.

<pre class="moss indent">
&gt; type(d) is Duck
true

&gt; d: Duck
true
</pre>

<p>The former is only true if the types match exactly.
The latter is also true if <code>d</code> is an descendant.
For example, <code>d: Bird</code> would also be true,
in case <code>Duck</code> inherits from <code>Bird</code>.

<h2 id="inheritance">Inheritance</h2>

<p>A class may inherit properties from a parent class.

<pre class="moss indent">
class Bird = {
   function fly()
      print(self.name, " flies.")
   end
}

class Duck: Bird = {
   function quack()
      print(self.name, " quacks.")
   end
}

d = table Duck{name="Dagobert"}
d.fly()
d.quack()
</pre>

<p>As Duck just points to Bird, changing Bird afterwards will be
reflected in Duck. This may be prevented by swallowing the
properties of Bird instead. Replace

<pre class="moss indent">
class Duck: Bird = {...}
</pre>

<p>by shallow copy:

<pre class="moss indent">
class Duck = record(Bird)|{...}
</pre>

<p>or by deep copy:

<pre class="moss indent">
class Duck = deep_copy(record(Bird))|{...}
</pre>

<p>The function <code>deep_copy</code> is not part of the
core language. You will find it in the standard library.

<h2 id="multiple-inheritance">Multiple inheritance</h2>

<p>A class may inherit from more than one parent.

<pre class="moss indent">
class Diver = {
   function dive()
      print(self.name, " dives.")
   end
}

class Bird = {
   function fly()
      print(self.name, " flies.")
   end
}

class Duck: [Bird, Diver] = {
   function quack()
      print(self.name, " quacks.")
   end
}

d = table Duck{name="Dagobert"}
d.fly()
d.dive()
d.quack()
</pre>

<p>A property is first searched in Duck, then in Bird
and then in Diver.

<p>Instead of pointing to Bird and Diver, we can
alternatively create a shallow copy:

<pre class="moss indent">
function extends(*a)
   buffer = {}
   for m in a
      buffer.extend(record(m))
   end
   return fn|m|
      buffer.update(m)
      return buffer
   end
end

class Diver = {
   function dive()
      print(self.name, " dives.")
   end
}

class Bird = {
   function fly()
      print(self.name, " flies.")
   end
}

class Duck = extends(Bird,Diver){
   function quack()
      print(self.name, " quacks.")
   end
}

d = table Duck{name="Dagobert"}
d.fly()
d.dive()
d.quack()
</pre>

<h2 id="composition">Composition over inheritance</h2>

<p>Inheritance has the disadvantage that it might lead to
name clashes. In case both ancestors have a method with the
same name, which one should be used? This problem is solved
by replacing inheritance with composition.

<p>The following approach enables automatic composition
by prefixing class properties.

<pre class="moss indent">
function compose(tab)
   buffer = {}
   for prefix, type in tab.items()
      for key, value in record(type).items()
         buffer[prefix+"_"+key] = value
      end
   end
   return fn|m|
      buffer.update(m)
      return buffer
   end
end

class Diver = {
   function dive()
      print(self.name, " dives.")
   end
}

class Bird = {
   function fly()
      print(self.name, " flies.")
   end
}

class Duck = compose{"bird": Bird, "diver": Diver}{
   function quack()
      print(self.name, " quacks.")
   end
}

d = table Duck{name="Dagobert"}
d.bird_fly()
d.diver_dive()
d.quack()
</pre>

<p>It might be that not only class properties clash, but also
object properties. To solve this problem, we need more fine-grained
control.

<pre class="moss indent">
class Diver = {
   function dive()
      print(self.name, " dives ", self.quickness, ".")
   end
}

class Bird = {
   function fly()
      print(self.name, " flies ", self.quickness, ".")
   end
}

class Duck = {
   function quack()
      print(self.name, " quacks.")
   end
}

function duck(argm)
   name = argm["name"]
   bq = argm["bird_quickness"]
   dq = argm["diver_quickness"]
   return table Duck{
      name = name,
      bird = table Bird{name = name, quickness = bq},
      diver = table Diver{name = name, quickness = dq}
   }
end

d = duck{
   name = "Dagobert",
   bird_quickness = "fast",
   diver_quickness = "very fast"
}
d.bird.fly()
d.diver.dive()
d.quack()
</pre>

<h2 id="reflection">Reflection</h2>

<p>Reflection is the possibility to construct, obtain and modify the
structure of a type at runtime. To achieve this, classes and objects
may constructed dynamically from data.

<pre class="moss indent">
Duck = class "Duck" {
   "quack": fn||
      print(self.("name"), " quacks.")
   end
}

d = table Duck{"name": "Dagobert"}
d.("quack")()
</pre>

<p>The properties are ordinary key-value maps:

<pre class="moss indent">
class_data = {
   "quack": fn||
      print(self.("name"), " quacks.")
   end
}
Duck = class "Duck" (class_data)

table_data = {"name": "Dagobert"}
d = table Duck(table_data)
d.("quack")()
</pre>

<p>The map may be accessed with <code>record</code>:

<pre class="moss indent">
m = record(Duck)
m["quack"](d;)
</pre>

<p>We have:
<pre class="moss indent">
d.name == d.("name") == record(d)["name"]
</pre>

<p>But note that the dot operation also searches in
the class and its ancestors, whereas the record lookup
does not.


<h2 id="aop">Aspect-oriented programming</h2>

<p>A class may be modified automatically in such a way, that
a special function called an <i>advice</i> enables us to do operations
before and after each method call. We will call this <i>wrapping</i>.
For example, a function <code>log</code> should print to the
command-line when a method starts and ends.

<pre class="moss indent">
function wrap(Class,advice)
   m = record(Class)
   for key, value in m.items()
      if type(value) is Function
         m[key] = |*argv| advice(key,value,self,argv)
      end
   end
end

function log(name,method,pself,argv)
   print("[Start of method {}]"%[name])
   rv = method(pself;*argv)
   print("[End of method {}]"%[name])
   return rv
end

class Duck = {
   function quack()
      print(self.name, " quacks.")
   end
}

wrap(Duck,log)

d = table Duck{name = "Dagobert"}
d.quack()
</pre>


<h2 id="prototypes">Prototypes</h2>

<p>Every object <code>x</code> has a prototype.
If some member object is not found in <code>x</code>, it will be
looked up in the prototype of <code>x</code> and then in the
prototype of the prototype of <code>x</code> and so on.

<p>In Moss, the type of an object and its prototype coincide,
because the type of an object is determined by its prototype.
The prototype stores the propertys and operations, that objects
of some kind have in common.

<pre class="moss cmd-box">
&gt; a = table{time="14:12"}
# a is a new object with prototype null

&gt; b = table a{}
# b is a new object with prototype a

&gt; type(b) is a
true

&gt; type(null) is null
true
# null is its own prototype and is the only
# object which shall have this property

&gt; b.time
"14:12"
# b does not have 'time', but a has it
</pre>

<p>There are two ways to determine, whether some object is of some
type or not.

<pre class="moss cmd-box">
&gt; T = table{}
&gt; S = table T{}
&gt; a = table S{}

# T is not the direct prototype of a.
&gt; type(a) is T
false
&gt; type(a) is S
true

# But a is an ancestor of T.
&gt; a: T
true
&gt; a: S
true

# S is a subtype of T.
&gt; S: T
true

# S is a direct subtype of T.
&gt; type(S) is T
true
</pre>

<p>If <code>S</code> was extended by <code>T</code>, we must
take a different approach.

<pre class="moss cmd-box">
&gt; T = table{a=1, b=2}
&gt; S = table{c=3}
&gt; extend(S,T)

# This won't work anymore.
&gt; S: T
false

# But one can test, whether all members of T
# are contained in S.
&gt; record(T) &lt; record(S)
true
</pre>

<h2 id="basic-data-types">Basic data types</h2>

<p>Variables of all basic data types as well as the data types
itself are objects. Thus the object system applies
to the basic data types too. Type checks are performed in one
of two ways:
<pre class="moss cmd-box">
&gt; x = 1
&gt; x: Int
true

&gt; type(x) is Int
true
</pre>

<p>Here is a list of the basic data types:
<pre class="indent">
Bool, Int, Long, Float, Complex,
Range, List, Map, String, Function.
</pre>

<p>A data type is written capitalized, the corresponding constructor
function in lower case.
<pre class="moss cmd-box">
&gt; list(1..10): List
true
</pre>


<h2 id="classes-and-metaclasses">Classes and Metaclasses</h2>

<p>To be honest, the coincidence between types and prototypes can
be broken. A table constructor may take a tuple of three parts
instead of a simple prototype. In general we have:
<pre class="moss indent">
x = table(type, name, prototype) {}
</pre>

<p>Properties are searched in <code>x</code> first and then
in the prototype chain. But <code>type(x)</code> will lead
to the type, not the prototype. The type of a type is sometimes
called a metaclass. The metaclass of the basic data types
is called <code>Type</code>. Thus we have:

<pre class="moss cmd-box">
&gt; type([])
List

&gt; type(List)
Type

&gt; prototype([])
List

&gt; prototype(List)
Iterable
</pre>

<p>Now, basic class construction is stated as follows:
<pre class="moss indent">
Bird = table(Type,"Bird"){
   function string()
      "{} is a bird." % [self.name]
   end,
   function fly()
      "{} can fly!" % [self.name]
   end
})

Duck = table(Type,"Duck",Bird){
   function string()
      "{} is a duck." % [self.name]
   end,
   function dive()
      "{} can dive!" % [self.name]
   end
})

d = table Duck{name = "Donald"}

print(d)
print(d.fly())
print(d.dive())
print("type: ", type(d))

# Output:
# Donald is a duck.
# Donald can fly!
# Donald can dive!
# type: Duck
</pre>

<h2>Multiple inheritance</h2>

<p>An object can have more than one prototype.

<pre class="moss indent">
Plane = table{
   function take_off()
      print(self.id, " is in the sky.")
   end
}

sea_duck = table[Ship, Plane]{
   id = "Sea duck",
   vmax = 40
}

sea_duck.move()
# Sea duck moves at 20 kn.

sea_duck.take_off()
# Sea duck is in the sky.
</pre>

<p>A method is searched at first in <code>Ship</code>,
and then, if not found, in <code>Plane</code>.


<h2 id="monkey">Monkey patching</h2>

<p>We are able to add methods to already existent types. This
technique is called <i>monkey patching</i> and considered a bad
practice, because it can result in name conflicts.

<p>As an example, we will add a method to the list type, that
splits the list into pairs.

<pre class="moss cmd-box">
&gt; List.pairs = || list(self.chunks(2))
&gt; list(1..4).pairs()
[[1,2], [3,4]]
</pre>

<h2 id="overloading">Operator overloading</h2>

<p>Table of binary overloadable operators:

<table class="bt indent">
<tr>
  <th>Op.
  <th>left
  <th>right
<tr>
  <td class="r"><code>a+b</code>
  <td><code>add</code>
  <td><code>radd</code>
<tr>
  <td class="r"><code>a-b</code>
  <td><code>sub</code>
  <td><code>rsub</code>
<tr>
  <td class="r"><code>a*b</code>
  <td><code>mul</code>
  <td><code>rmul</code>
<tr>
  <td class="r"><code>a/b</code>
  <td><code>div</code>
  <td><code>rdiv</code>
<tr>
  <td class="r"><code>a//b</code>
  <td><code>idiv</code>
  <td><code>ridiv</code>
<tr>
  <td class="r"><code>a^b</code>
  <td><code>pow</code>
  <td><code>rpow</code>
<tr>
  <td class="r"><code>a&amp;b</code>
  <td><code>band</code>
  <td><code>rband</code>
<tr>
  <td class="r"><code>a|b</code>
  <td><code>bor</code>
  <td><code>rbor</code>
<tr>
  <td class="r"><code>a==b</code>
  <td><code>eq</code>
  <td><code>req</code>
<tr>
  <td class="r"><code>a&lt;b</code>
  <td><code>lt</code>
  <td><code>rlt</code>
<tr>
  <td class="r"><code>a&lt;=b</code>
  <td><code>le</code>
  <td><code>rle</code>
</table>

<p>Table of unary overloadable operators:
<table class="bt indent">
<tr>
  <th>Op.
  <th>Method
<tr>
  <td class="r"><code>-a</code>
  <td><code>neg</code>
<tr>
  <td class="r"><code>~a</code>
  <td><code>comp</code>
</table>

<p>Here is an implementation of complex number arithmetic.
Complex numbers are covered already by the Moss language,
but this implementation allows also for arithmetic of
complex integers.

<pre class="moss indent">
function complex(x,y)
   return table Complex{re=x, im=y}
end

Complex = table(Type,"Complex"){
   function string()
      return "({}|{})" % [self.re, self.im]
   end,

   function neg()
      return table Complex{re = -self.re, im = -self.im}
   end,

   function add(a;b)
      if b: Complex
         return table Complex{re = a.re+b.re, im = a.im+b.im}
      else
         return table Complex{re = a.re+b, im = a.im}
      end
   end,

   function radd(a;b)
      return table Complex{re = a+b.re, im = b.im}
   end,

   function sub(a;b)
      if b: Complex
         return table Complex{re = a.re-b.re, im = a.im-b.im}
      else
         return table Complex{re = a.re-b, im = a.im}
      end
   end,

   function rsub(a;b)
      return table Complex{re = a-b.re, im = -b.im}
   end,

   function mul(a;b)
      if b: Complex
         return table Complex{
            re = a.re*b.re-a.im*b.im,
            im = a.re*b.im+a.im*b.re
         }
      else
         return table Complex{re = a.re*b, im = a.im*b}
      end
   end,

   function rmul(a;b)
      return table Complex{re = a*b.re, im = a*b.im}
   end,

   function div(a;b)
      if b: Complex
         r2 = b.re*b.re+b.im*b.im
         return table Complex{
            re = (a.re*b.re+a.im*b.im)/r2,
            im = (a.im*b.re-a.re*b.im)/r2
         }
      else
         return table Complex{re = a.re/b, im = a.im/b}
      end
   end,

   function rdiv(a;b)
      r2 = b.re*b.re+b.im*b.im
      return table Complex{
         re = a*b.re/r2,
         im = -a*b.im/r2
      }
   end,

   function pow(a;n)
      return (1..n).prod(|k| a)
   end
}
</pre>

<p>Example of use:
<pre class="moss cmd-box">
&gt; i = complex(0,1)
&gt; 4+2*i
(4, 2)

&gt; (4+2*i)*(5+3*i)
(14, 22)

&gt; (4+2*i)^60
(-964275081903216557328422924784146317312,
  472329409445772258729579365571477110784)

&gt; (4+2i)^60
-9.64275e+38+4.72329e+38i
</pre>


<h2 id="read-only">Read-only properties</h2>

<p>Sometimes only methods that belong to the object should have write
access to a property. Such a close relationship of the object
to its methods can be achieved by a closure-binding of an interal
private property table.

<pre class="moss indent">
Ship = table{}

function ship
   private_tab = {color = "blue"}
   return table Ship{
      function get(property)
         return private_tab[property]
      end,
      function change_color()
         private_tab["color"] = "green"
      end
   }
end

Bristol = ship()
print(Bristol.get("color"))
Bristol.change_color()
print(Birstol.get("color"))
</pre>
<p>Every method that has direct access to <code>private_tab</code>
must belong to <code>ship</code> and not to its
type <code>Ship</code>.

<h2 id="private">Private properties</h2>

<p>Private properties are constructed the same way as read-only
properties. Only methods that belong to the object should be able
to see the properties.

<pre class="moss indent">
Ship = table{}

function ship
   private_tab = {color = "blue"}
   return table Ship{
      function info()
         return "A {} ship." % private_tab["color"]
      end,
      function change_color()
        private_tab["color"] = "green"
      end
   }
end

Bristol = ship()
print(Bristol.info())
Bristol.change_color()
print(Bristol.info())
</pre>

<h2 id="advanced">Advanced classes</h2>

<p>Advanced classes allow for features like getters, setters
and destructors. Such classes are created by the function
<code>class</code>:
<pre class="moss indent">
Object = class{
   name = "Object",
   get = |key| "~{}~"%[record(self)[key]],
   drop = || print("dropped")
}

t = table Object{x=1,y=2}
print(t.x)
</pre>
<p>This program prints:
<pre class="indent">
~1~
dropped
</pre>

<h2 id="custom">Custom class constructors</h2>

<pre class="moss">
# An implementation of prototyping inheritance.
function get(key)
   data = record(self)
   while true
      if key in data
         return data[key]
      elif "prototype" in data
         data = record(data["prototype"])
      else
         raise "key '{}' not found" % [key]
      end
   end
end

function set(key,value)
   record(self)[key] = value
end

# A custom class constructor.
function pclass(m)
   m["get"] = get
   m["set"] = set
   return class(m)
end

Object = pclass{name = "Object"}

a = table Object{x=1,y=2}
b = table Object{z=3,prototype=a}
print([b.x,b.y,b.z])

# Output:
# [1, 2, 3]
</pre>


</body>
</html>


