<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Algorithms</title>
  <link href="../css/main.css" rel="stylesheet">
  <script src="../js/moss-syntax.js"></script>
</head>
<body>

<table class="navigation">
<tr><td><b>&uarr;</b> <a href="toc.htm">Up</a>
</table>
<h1>Algorithms</h1>

<div class="toc">
<h2 id="toc">Table of contents</h2>
<ol>
<li><a href="#itertools">Module <code>itertools</code> &mdash; functions that create iterators</a>
<li><a href="#functional">Module <code>functional</code> &mdash; functional programming</a>
</ol>
</div>

<h2 id="itertools">Module itertools</h2>
<p>Functions that create iterators.

<dl class="code">
<dt>chain(*iterables)
<dd>Lazy evaluation of <code>iter(iterables.sum(list))</code>.
<pre class="moss">
&gt; chain(1..2,1..4).list()
[1, 2, 1, 2, 3, 4]
</pre>

<dt>permutations(a)
<dd>Return an iterator over all permutations of <code>a</code>.

<dt>repeat(x), repeat(x,n)
<dd>Return an iterator that returns <code>x</code> over and over
again. If <code>n</code> is given, the iterator will be exhausted
after <code>n</code> calls.
</dl>

<h2 id="functional">Module functional</h2>
<p>Functional programming.

<dl class="code">
<dt>fix(F)
<dd>Memoizing fixed point combinator.
<pre class="moss">
fib = fix(|f,n| 1 if n==1 or n==2 else f(n-1)+f(n-2))
</pre>

<dt>lazy(|| expression)
<dd>Create a new lazily evaluated expression. Evaluation of a
such an expression <code>x</code> is done by <code>x.value()</code>.
The expression is evaluated only once, the result then memoized for
subsequent calls.

<dt>Lazy
<dd>Data type of lazily evaluated expressions.
</dl>

</body>
</html>

