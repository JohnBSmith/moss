
= TODO LIST =
== Interpreter kernel ==
* get property or null
* tracebacks
* in a coroutine let all exit paths
  perform a loop as "yield; return empty"
  (resume after a last yield and return empty immediately)
* delete temporary variables after use
* coroutines
* continuations, call/cc
* custom detstructors
* sandbox security model for file access
* a security model by functions that can be called only once
* interning literals of type Long
* in range to iterator/list: start/end of type Long
* search paths

== Library ==
* reverse iterator
* iterator: tee
* rotate a list
* regular expressions
* graphics

=== Linear algebra ===
* polymorphic arrays
  * array to list
* homogeneous arrays
  * BLAS compatible interface

=== OS Interface ===
* change directory
* list files, subdirectories
* file access

=== Network, Cryptography ==
* SHA3-256 interface
* AES-256 interface
* ECDH interface
* sockets
* TLS-1.3 sockets
* https interface


== Audits ==
* break 'r in vm.rs: replace vs. clone
* overflow by integer arithmetic
* overflow by type conversion
* search for "as usize", "as isize", "as i32", "as u32", etc.


= Problems =
* getattr(x,key) cannot differentiate between null
  and non-existence.
* m.(key) looks like m(key), but behaves differently.
  The former raises an exception, the latter returns null if
  a key is not found. Maybe m.[key] is a better syntax.


= DONE =
== Interpreter kernel ==
* format strings
* try-catch
* exception objects
* load a module only once, then Rc::clone
* floating point range to list
* operator overloading
* multiple dispatch in operator overloading
* env-pointer in Interface::to_string
* interface objects in hash tables
* assert statement

== Library ==
* zip
* cycling iterator
* extend for objects
* long
* hash for Long
* powmod
* cartesian power
* Iterable.join

=== Linear Algebra ===
* polymorphic arrays
  * scalar product
  * absolute value of a vector
  * matrix multiplication


